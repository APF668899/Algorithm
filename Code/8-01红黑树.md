# 红黑树的介绍
## 二叉搜索树的缺陷
* 二叉搜索树作为数据存储的结构由重要的优势:
  * 可以快速地找到给定关键字的数据项并且可以快速地插入和删除数据项
* 二叉搜索树有一个很麻烦的问题:
  * 如果插入的数据时有序的数据，比如下面的情况
  * 有一棵初始化为9 8 12的二叉树
  * 插入下面的数据: 76543
* 非平衡树:
  * 比较好的二叉搜索树数据应该是左右分布均匀的
  * 但是插入连续数据后，分布的不均匀，我称这种树为非平衡树.
  * 对于棵平衡二 叉树来说，插入/查找等操作的效率是O(logN)
  * 对于棵非平衡二叉树，相当于编写了一个链表，查找效率变成了O(N)
## 树的平衡性
### AVL树:
* AVL树是最早的种平衡树.它有些办法保持树的平衡(每个节点多存储了一个额外的数据)
* 因为AVL树是平衡的，所以时间复杂度也是O(logN).
* 但是,每次插入/删除操作相对于红黑树效率都不高,所以整体效率不如红黑树
### 红黑树:
* 红黑树是平衡树，所以时间复杂度也是在O(logN).
* 另外插入/删除等操作，红黑树的性能要优于AVL树，所以现在平衡树的应用基木都是红黑树.
## 红黑树的规则
1. 节点是红色或黑色。
2. 根节点是黑色。
3. 每个叶子节点都是黑色的空节点( NIL节点)。
4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5. 从任一节 点到其每个叶子的所有路径都包含相同数目的黑色节点
![红黑树的规则](https://gitee.com/MrFlySand/Other/raw/master/Material/Image/Algorithm/8-01-P01.png)
## 红黑树的相对平衡
* 结果就是这个树基本是平衡的.可以保证在最坏的情况下，依然是高效的.
* 从根到叶子的最长可能路径，不会超过最短可能路径的两倍长.
  * 性质4决定了路径不能有两个相连的红色节点.口最短的可能路径都是黑色节点
  * 最长的可能路径是红色和黑色交替.
  * 性质5所有路径都有相同数目的黑色节点.
  * 这就表明了没有路径能多余任何其他路径的两倍长.
## 变色
* 插入一个新节点时，有可能树不再平衡，可以通过三种方式的变换，让树保持平衡
  * 换色-左旋转-右旋转
* 变色:
  * 为了重新符合红黑树的规则，尝试把红色节点变为黑色，或者把黑色节点变为红色。
  * 插入的新的节点通常都是红色节点
  * 因为在插入节点为红色的时候，有可能插入一次是不违反红黑树任何规则的
  * 而插入黑色节点 必然会导致有一条路径上多了黑色节点， 这是很难调整的.
  * 红色节点可能导致出现红红相连的情况，但是这种情况可以通过颜色调换和旋转来调整
## 旋转
### 左旋转
* 逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。
* 图中，身为左孩子的Y取代了X的位置，而X变成了Y的
![左旋转](https://gitee.com/MrFlySand/Other/raw/master/Material/Image/Algorithm/8-01-P02.png)
### 右旋转
* 顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子
* 图中，身为右孩子的Y取代了X的位置，而X变成了Y的
![右旋转](https://gitee.com/MrFlySand/Other/raw/master/Material/Image/Algorithm/8-01-P03.png)

## 插入操作
* 插入:
  * 设要插入的节点为N,其父节点为P
  * 其祖父节点为G,其父亲的兄弟节点为U(即P和U是同个节点的子节点).
* 情况一:
  * 新节点N位于树的根上，没有父节点
  * 这种情况下，我们直接将红色变换成黑色即可，这样满足性质2.
* 情况二:
  * 新节点的父节点P是黑色
  * 性质4没有失效(新节点是红色的)，性质5也没有任何问题.
  * 尽管新节点N有两个黑色的叶子节点nil,但是心节点N是红色的，所以通过它的路径中黑色节点的个数依然相同，满足性质5
* 情况三:
  * P为红色，U也是红色
  * 父红叔红祖黑
  * 父黑权黑祖红
  * 操作方案:
    * 将P和U变换为黑色，并且将G变换为红色
    * 现在新节点N有了一个黑色的父节点P所以每条路径上黑色节点的数目没有改变
    * 而从更高的路径上，必然都会经过G节点所以那些路径的黑色节点数目也是不变的符合性质5.可能出现的问题:
    * 但是N的祖父节点G的父节点也可能是红色，这就违反了性质3,可以递归的调整颜色
    * 但是如果递归调整颜色到了根节点就需要进行旋转了，待会儿我们的例子中会遇到这个问题
![情况三](https://gitee.com/MrFlySand/Other/raw/master/Material/Image/Algorithm/8-01-P04.png)    
* 情况四
  * N的叔叔U是黑节点且N是做孩子
  * 父红叔黑祖黑N是左儿子
  * 父黑
  * 祖红
  * 右旋转
  * 操作方案:
    * 对祖父节点G进行依次右旋转
    * 在旋转查收的树中，以前的父节点P现在是新节点已经以前祖父节点G的父节点
    * 交换以前的父节点P和祖父节点G的颜色.(P为黑色G变成红色- G原来定是 黑色，为什么?)
    * B节点向右平移，称为G节点的左子节点
![情况四](https://gitee.com/MrFlySand/Other/raw/master/Material/Image/Algorithm/8-01-P05.png)        
## 情况五:
  * N的叔叔U是黑色节点，且N是有孩子，父红叔黑祖黑N是右儿子
  * 以P为根左旋转
  * 将P作为新插入的红色节点考虑即可
  * 自己变成黑色
  * 祖变成红色
  * 以祖为根进行右旋转
  * 操作方案:
    * 对P节点进行依次左旋转形成情况四的结果
    * 对祖父节点G进行一次右旋转并且改变颜色即可
![情况五](https://gitee.com/MrFlySand/Other/raw/master/Material/Image/Algorithm/8-01-P06.png)        
     
