### 时间复杂度O(n)
* 最直观的方法，根据定义，因为质数除了1和本身之外没有其他约数，所以判断n是否为质数，根据定义直接判断从2到n-1是否存在n的约数即可
```js
  function  isPrime(num){
      for (var i = 2;i <= n-1;i++) {
        if(num % i ==0){
          return false;
        }
      }
      return true;
    }
```
### 时间复杂度O(logN)
* 上述判断方法，明显存在效率极低的问题。对于每个数n，其实并不需要从2判断到n-1，我们知道，一个数若可以进行因数分解，那么分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n)，据此，上述代码中并不需要遍历到n-1，遍历到sqrt(n)即可，因为若sqrt(n)左侧找不到约数，那么右侧也一定找不到约数
```js
  function  isPrime(num){
      var temp = parseInt(Math.sqrt(num));
      if(num ==2|| num==3 )
        return true;
      for (var i = 2;i <= temp;i++) {
        if(num % i ==0){
          return false;
        }
      }
      return true;
    }
```
### 时间复杂度
```js
function  isPrime(num){
  var temp = parseInt(Math.sqrt(num));	
    if(num ==2|| num==3 )
      return true;
    if(num % 2 == 0){
      return false;
    }
    if(num % 3 == 0){
      return false;
    }
    if(num % 5 == 0){
      return false;
    }
    for (var i = 7;i <= temp;i=i+2) {
      if(num % i == 0){
        return false;
      }
    }
  }
  return true;
}
```
### 时间复杂度
```js
function  isPrime(num){
  var temp = parseInt(Math.sqrt(num));				
    if(num % 2 == 0){
      return false;
    }
    if(num % 3 == 0){
      return false;
    }
    if(num % 5 == 0){
      return false;
    }
    for (var i = 7;i <= temp;i=i+2) {
      if(num % i == 0){
        return false;
      }
    }
  }
  return true;
}
```
