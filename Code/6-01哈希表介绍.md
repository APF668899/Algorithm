# 哈希表介绍
1. 哈希表是一种非常重要的数据结构，但是很多学习编程的人一直搞不懂哈希表到底是如何实现的.
2. 在这一章节中，我们就一点点来实现一个自己的哈希表通过实现来理解哈希表背后的原理和它的优势.
3. 几乎所有的编程语言都有直接或者间接的应用这种数据结构
4. 哈希表通常是基于数组进行实现的，但是相对于数组，它也很多的优势:
   * 它可以提供非常快速的插入删除查找操作
   * 无论多少数据，插入和删除值需要接近常量的时间:即O(1)的时间级实际上，只需要几个机器指令即可完成0哈希表的速度比树还要快，基本可以瞬间查找到想要的元素
   * 哈希表相对于树来说编码要容易很多，
5. 哈希表相对于数组的一些不足
   * 哈希表中的数据是没有顺序的，所以不能以一种固定的方式(比如从小到大)来遍历其中的元素
   * 通常情况下，哈希表中的key是不允许重复的，不能放置相同的key,用于保存不同的元素
## 案例
* 假如一家公司有1000个员工 现在我们需要将这些员工的信息使用某种数据结构来保存起来口你会采用什么数据结构呢
1. 方案一数组
   * 一种方案是按照顺序将所有的员工依次存入一 个长度为1000的数组中每个员工的信息都保存在数组的某个位置上
   * 但是我们要查看某个具体员工的信息怎么办呢?一个个找吗?不太好找
   * 数组最大的优势是什么?通过下标值去获取信息
   * 所以为了可以通过数组快速定位到某个员工最好给员工信息中添加一个员工编号(工号)而编号对应的就是员工的下标值
   * 当查找某个员工的信息时通过员工编号可以快速定位到员工的信息位置
2. 方案二链表
   * 链表对应插入和删除数据有一定的优势
   * 但是对于获取员工的信息每次都必须从头遍历到尾这种方式显然不是特别适合我们这里
3. 最终方案:
   * 假如我想查看一FHurry这位员工的信息但是我不知道Hurry的员工编号你怎么办呢?
   * 当然你说我可以问他但是你每查找个员工都是问下这个员工的编号吗?不合适
   * 能不能有一种力法让Hurry的名字和它的员工编号产生直接的关系呢?也就是通过Hurry这个名字我就能获吸到它的索引值而再通过索引值我就能获取到Hurry的信息呢?
   * 使用哈希函数让某个key的信息和索引值对应起来
## 方案一:字母转数字
* 将字符串转成下标值
* 怎样才能将一个字符串转成数组的下标值呢?
  * 单词/字符串转下标值其实就是字母/文字转数字
  * 我们需要设计种方案，可以将单词转成适当的下标:
  * 计算机中有很多的编码方案就是用数字代替单词的字符就是字符编码.(常见的字符编码?)
  * 比如ASCII编码: a是97, b是98,依次类推122代表z
  * 我们也可以设计一个自己的编码系统比如a是1, b是2, c是3,依次类推，z是26个数
  * 当然我们可以加上空格用0代替，就是27个字符(不考虑大写问题)多
  * 有了编码系统后，一个单词如何转成数字呢?   
* 方案:数字相加
  * 一种转换单词的简单方案就是把单词每个字符的编码求和.
  * 例如单词cats转成数字: 3+1+20+ 19=43,那么43就作为cats单词的下标存在数组中
* 问题:按照这种方案有一个很明显的问题就是很多单词最终的下标可能都是43.
  * 比如was/tin/give/tend/moan/tick等等
  * 我们知道数组中一个下标值位置只能存储一个数据
  * 如果存入后来的数据，必然会造成数据的覆盖
  * 一个下标存储这么多单词显然是不合理的.
## 方案二:字母转数字的方案
* 幂的连乘
  * 现在，我们想通过一种算法，让cats转成数字后不那么普通.
  * 数字相加的方案就有些过于普通了.
  * 有一种方案就是使用幂的连乘，什么是幂的连乘呢?
  * 其实我们平时使用的大于10的数字，可以用一种幕的连乘来表示它的唯一性:比如: 7654 = 7*103+6*102+5*10+4
  * 我们的单词也可以使用这种方案来表示比如cats = 3* 273+ 1*272+20*27+17= 60337
  * 这样得到的数字可以基本保证它的唯一 性不会和别的单词重复
* 问题:如果一词zzzzzzzzzz般英文单词不会超过10个字符).那么得到的数字超过700000000000.数组可以表示这么大的下标值吗?
  * 而且就算能创建这么大的数组，事实上有很多是无效的单词
  * 创建这么大的数组是没有意义的
* 两种方案总结:
  * 第一种方案(把数字相加求和)产生的数组下标太少.
  * 第二种方案(与27的幂相乘求和)产生的数组下标又太多.
## 哈希表的一些概念
* 认识情况了上面的内容，相信你应该懂了哈希表的原理了，我们来看看几个概念:
  * 哈希化:将大数字转化成数组范围内下标的过程，我们就称之为哈希化
  * 哈希函数:通常我们会将单词转成大数字，大数字在进行哈希化的代码实现放在一个函数中， 这个函数我们成为哈希函数.
  * 哈希表:最终将数据插入到的这个数组，对整个结构的封装，我们就称之为是一个哈希表
* 但是，我们还有问题需要解决:
  * 虽然我们在一个100000的数组中， 放50000个单词已经足够.
  * 但是通过哈希化后的下标值依然可能会重复，如何解决这种重复的问题呢?
## 什么是冲突?
* 尽管50000个单词，我们使用了100000个位置来存储并且通过一种相对比较好的哈希函数来完成但是依然有可能会发生冲突.
  * 比如melioration这个单词， 通过哈希函数
  * 得到它数组的下标值后，发现那个位置上已经存在一个单词demystif
  * 因为它经过哈希化后和melioration得到的下标实现相同的.
* 这种情况我们成为冲突
* 虽然我们不希望这种情况发生，当然更希望每个下标对应一个数据项，但是通常这是不可能的
* 冲突不可避免，我们只能解决冲突.
* 就像之前0~ 199的数字选取5个放在长度为10的单元格中
  * 如果我们随机选出来的是33, 82, 11, 45, 90,那么最终它们的位置会是3-2-1-5-0,没有发生冲突
  * 但是如果其中有一个33,还有一个73呢?还是发生了冲突
* 我们需要针对这种冲突提出一些解决方案
  * 即使冲突的可能性比较小， 你依然需要考虑到这种情况
  * 以便发生的时候进行对应的处理代码.
* 如何解决这种冲突呢?常见的情况有两种方案
  * 链地址法
  * 开放地址法
## 链地址法解析
* 图片解析:
  * 从图片中我们可以看出，链地址法解决冲突的办法是每个数组单元中存储的不再是单个数据，而是一个链条.
  * 这个链条使用什么数据结构呢?常见的是数组或者链表.
  * 是链表，也就是每个数组单元中存储着一个链表 -旦发现重复将重复的元素插入到链表的首端或者末端即可
  * 询时，先根据哈希化后的下标值找到对应的位置再取出链表，依次查询找寻找的数据
* 还是链表呢?
  * 数组或者链表在这里其实都可以效率上也差不多.
  * 因为根据哈希化的index找出这个数组或者链表时，通常就会使用线性查找这个时候数组和链表的效率是差不多的
  * 当然在某些实现中，会将新插入的数据放在数组或者链表的最前面，因为觉得新插入的数据用于取出的可能性更大
  * 这种情况最好采用链表，因为数组在首位插入数据是需要所有其他项后移的，链表就没有这样的问题
  * 当然我觉得出于这个也看业务需求不见得新的数据就访问次数会更多比如我们微信新添加的好友，可能是刚认识的，联系的频率不见得比我们的老朋友更多，甚至新加的只是聊一两句.
  * 所以，这里个人觉得选择数据或者链表都是可以的.  
## 开放地址法
* 开放地址法其实就是要寻找空白的位置来放置冲突的数据项
* 探索这个位置的方式不同，有三种方法:
  * 线性探测
  * 二次探测
  * 再哈希法
## 二次探测
* 线性探测存在的问题:
  * 如果之前的数据是连续插入的，那么新插入的一个数据可能需要探测很长的距离.
* 二次探测在线性探测的基础上进行了优化:
  * 二次探测主要优化的是探测时的步长，什么意思呢?
  * 线性探测，我们可以看成是步长为1的探测，比如从下标值x开始，那么线性测试就是x+1, x+2, x+ 3依次探测.0二次探测，对步长做了优化，比如从下标值x开始，x+12, x+22, x+32.
  * 这样就可以一次性探测比较长的距离，比避免那些聚集带来的影响.
* 二次探测的问题:
  * 但是二次探测依然存在问题，比如我们连续插入的是32-112-82-2-192,那么它们依次累加的时候步长的相同的.
  * 也就是这种情况下会造成步长不一的一种聚集.还是会影响效率.(当然这种可能性相对于连续的数字会小一些
  * 怎么根本解决这个问题呢?让每个人的步长不一样，一起来看看再哈希法吧  
## 再哈希法
* 为了消除线性探测和二次探测中无论步长+ 1还是步长+平法中存在的问题，还有一种最常用的解决方案:再哈希法
* 再哈希法:
  * 二次探测的算法产生的探测序列步长是固定的: 1, 4, 9, 16,依次类推
  * 现在需要种方法产生种依赖关键字的探测序列，而不是每个关键字都一样.
  * 那么，不同的关键字即使映射到相同的数组下标，也可以使用不同的探测序列.
  * 再哈希法的做法就是:把关键字用另外个哈希函数，再做一次哈希化用这次哈希化的结果作为步长
  * 对于指定的关键字，步长在整个探测中是不变的，不过不同的关键字使用不同的步长.

* 第二次哈希化需要具备如下特点:
  * 和第一个哈希函数不同(不要再使用上一 次的哈希函数了，不然结果还是原来的位置)
  * 不能输出为0(否则，将没有步长每次探测都是原地踏步，算法就进入了死循环)
* 其实， 我们不用费脑细胞来设计了，计算机专家已经设计出种工作很好的哈希函数:
  * stepSize = constant - (key - constant)
  * 其中constant是质数 且小于数组的容量.
  * 例如: stepSize = 5 - (key % 5), 满足需求，并且结果不可能为0.
## 哈希化的效率
* 哈希表中执行插入和搜索操作效率是非常高的
  * 如果没有产生冲突，那么效率就会更高。
  * 如果发生冲突，存取时间就依赖后来的探测长度。
  * 平均探测长度以及平均存取时间,取决于填装因子，随着填装因子变大，探测长度也越来越长。
  * 随着填装因子变大，效率下降的情况，在不同开放地址法方案中比链地址法更严重，所以我们来对比一下他们的效率，再决定我们选取的方案
* 在分析效率之前，我们先了解个概念装填因子.
  * 装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值.
  * 装填因子=总数据项/哈希表长度
  * 开放地址法的装填因子最大是多少呢? 1, 因为它必须寻找到空白的单元才能将元素放入
  * 链地址法的装填因子呢?可以大于1,因为拉链法可以无限的延伸下去，只要你愿意(当然后面效率就变低了)
## 快速计算:霍纳法则
* 在前面，我们计算哈希值的时候使用的方式
  * cats = 3*273+1*272+20*27+17= 60337
* 这种方式是直观的计算结果，那么这种计算方式会进行几次乘法几次加法呢?
  * 当然我们可能不止4项，可能有更多项
  * 我们抽象下， 这个表达式其实是个多项式
  * a(n)x^n+ a(-1)x^(n-1)+ .. +a(1)x+ a(0)
* 现在问题就变成了多项式有多少次乘法和加法:
  * 乘法次数:n+(n- 1..+. 1= n(n+1)/2
  * 加法次数: n次
* 多项式的优化:霍纳法则
  * 解决这类求值问题的高效算法一霍纳法则。在中国，霍纳法则也被称为秦九韶算法。
* 通过如下变换我们可以得到一种快得多的算法，即
  * Pn(x)= anx^n+a(n - 1)x^(n-1)+ .+a1x+a0=
  * ((...(((anx +an - 1)x+an - 2)x+ an - 3)...)x+a1)x+a0)，
  * 这种求值的安排我们称为霍纳法则
* 变换后，我们需要多少次乘法，多少次加法呢?
  * 乘法次数: N次
  * 加法次数: N次
* 如果使用大0表示时间复杂度的话，我们直接从O(N2)降到了O(N).
## 优秀的哈希函数
* 哈希函数应该尽可能让计算的过程变得简单，提高计算的效率.
  * 哈希表的主要优点是它的速度，所以在速度上不能满足，那么就达不到设计的目的了.
  * 提高速度的一个办法就是让哈希函数中尽量少的有乘法和除法.因为它们的性能是比较低的
* 设计好的哈希函数应该具备哪些优点呢?
  * 快速的计算
    * 哈希表的优势就在于效率，所以快速获取到对应的hashCode非常重要
    * 我们需要通过快速的计算来获取到元素对应的hashCode
  * 均匀的分布
    * 哈希表中无论是链地址法还是开放地址法，当多个元素映射到同一个位置的时候都会影响效率.
    * 所以优秀的哈希函数应该尽可能将元素映射到不同的位置让元素在哈希表中均匀的分布


  




